---
title: "CS598PSL Project 4"
author: "Akshay Nair - akshayn5"
date: "2022-12-03"
output: html_document
---
# Setup
```{r}
library(recommenderlab)
library(slam)
library(data.table)
library(reshape2)
library(dplyr)
set.seed(1904)
myurl = "https://liangfgithub.github.io/MovieData/"
ratings = read.csv(paste0(myurl, 'ratings.dat?raw=true'), 
                   sep = ':',
                   colClasses = c('integer', 'NULL'), 
                   header = FALSE)
colnames(ratings) = c('UserID', 'MovieID', 'Rating', 'Timestamp')
movies = readLines(paste0(myurl, 'movies.dat?raw=true'))
movies = strsplit(movies, split = "::", fixed = TRUE, useBytes = TRUE)
movies = matrix(unlist(movies), ncol = 3, byrow = TRUE)
movies = data.frame(movies, stringsAsFactors = FALSE)
colnames(movies) = c('MovieID', 'Title', 'Genres')
movies$MovieID = as.integer(movies$MovieID)
movies$Title = iconv(movies$Title, "latin1", "UTF-8")
movies$Year = as.numeric(unlist(
  lapply(movies$Title, function(x) substr(x, nchar(x)-4, nchar(x)-1))))
small_image_url = "https://liangfgithub.github.io/MovieImages/"
movies$image_url = sapply(movies$MovieID, 
                          function(x) paste0(small_image_url, x, '.jpg?raw=true'))
```

# System I

## Scheme 1

In the first scheme, we define most popular as "number of ratings".
We filter to movies in the user's preferred genre (say, Action) then count number of ratings.
```{r}
genres = as.data.frame(movies$Genres, stringsAsFactors=FALSE)
tmp = tstrsplit(genres[,1], '[|]')[[1]]
movies_filtered = movies["Action" == tmp,]
ratings_filtered = ratings %>% 
  group_by(MovieID) %>% 
  summarize(ratings_per_movie = n(), ave_ratings = mean(Rating)) %>%
  inner_join(movies_filtered, by = 'MovieID') %>%
  filter(ratings_per_movie > 2000)

ratings_filtered %>%
  arrange(desc = -ratings_per_movie) %>%
  print(n = 5)
```

## Scheme 2

In the first scheme, we define most popular as "highest average rating".
We filter to movies in the user's preferred genre, and only show movies with at least 2000 ratings.

```{r}
ratings_filtered %>%
  top_n(10, ave_ratings) %>%
  arrange(desc(ave_ratings)) %>%
  print(n = 5)
```

# System II

## Setup
```{r}
i = paste0('u', ratings$UserID)
j = paste0('m', ratings$MovieID)
x = ratings$Rating
tmp = data.frame(i, j, x, stringsAsFactors = T)
Rmat = sparseMatrix(as.integer(tmp$i), as.integer(tmp$j), x = tmp$x)
rownames(Rmat) = levels(tmp$i)
colnames(Rmat) = levels(tmp$j)
Rmat = new('realRatingMatrix', data = Rmat)

train = Rmat[1:500, ]
test = Rmat[501, ]

```

## UBCF

### Generate Prediction
```{r}
trains <- as(train, "matrix")
tests = as(test, "matrix")
mean_trains = rowMeans(trains, na.rm = TRUE)
mean_tests = mean(tests, na.rm = TRUE)
trains = trains - mean_trains
tests = tests - mean_tests
S = proxy::simil(trains, tests, method = "cosine")
S = (1 + S) / 2
top_S = S[order(-S)[1:20], , drop = FALSE]

top_trains = merge(data.frame(trains), top_S, by = 'row.names', all = FALSE)
rownames(top_trains) = top_trains[,1]
top_trains = top_trains[,-1]
mypred = colSums(t(apply(top_trains, 1, function(x) { x[length(x)] * x[-length(x)] })), na.rm = TRUE)
for (i in 1:length(mypred)) {
  mypred[i] = mypred[i] / sum(top_trains[!is.na(top_trains[,i]),ncol(top_trains)])
}
mypred[mypred == 0 | is.infinite(mypred)] = NA
mypred[!is.na(tests)] = NA
mypred = mypred + mean_tests

```

### Compare to RecommenderLab
#### NA is the same

The number of non-predicted values is the same.
```{r}
recommender.UBCF <- Recommender(train, method = "UBCF",
                                parameter = list(normalize = 'center', 
                                                 method = 'Cosine', 
                                                 nn = 20))

p.UBCF <- predict(recommender.UBCF, test, type="ratings")
p.UBCF <- as.numeric(as(p.UBCF, "matrix"))

sum(is.na(p.UBCF) != is.na(mypred))
```

#### Predictions are close

The max difference of predicted values is less than 1e-06.
```{r}
max(abs(p.UBCF - mypred), na.rm = TRUE)
```

## IBCF
### Generate Prediction
```{r}
names(tests) = colnames(trains)
S = proxy::simil(t(trains), method = "cosine", drop0 = TRUE, use_nan = TRUE)
S = (1 + as.matrix(S, diag = 0)) / 2
mypred = rep(NA, nrow(S))
for (i in 1:nrow(S)) {
  S_i = S[i,]
  S_filtered = S_i[!is.na(S_i)]
  top_S = S_filtered[tail(order(S_filtered, decreasing = FALSE), 30), drop = FALSE]
  top_S = top_S[!is.na(top_S)]
  tests_filtered = tests[names(top_S)]
  top_S = top_S[!is.na(tests_filtered)]
  if (length(top_S) > 0) {
    mypred[i] = tests_filtered[!is.na(tests_filtered)] %*% top_S / sum(top_S, na.rm = TRUE)
  }
}
mypred[mypred == 0 | is.infinite(mypred)] = NA
mypred[!is.na(tests)] = NA
mypred = mypred + mean_tests
```


### Compare to RecommenderLab
#### NA is similar

We have less than 10 NA disagreements.
```{r}
recommender.IBCF <- Recommender(train, method = "IBCF",
                                parameter = list(normalize = 'center', 
                                                 method = 'Cosine', 
                                                 k = 30))

p.IBCF <- predict(recommender.IBCF, test, type="ratings")
p.IBCF <- as.numeric(as(p.IBCF, "matrix"))

sum(is.na(p.IBCF) != is.na(mypred))  
```

#### Predictions are close

This is less than 10% (0.1).
```{r}
mydiff = abs(p.IBCF - mypred)
sum(mydiff[!is.na(mydiff)] > 1e-6) / sum(!is.na(mydiff)) 
```
